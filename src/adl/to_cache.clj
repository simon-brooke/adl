(ns ^{:doc "Application Description Language: generate caching layer for database requests."
      :author "Simon Brooke"}
  adl.to-cache
  (:require [adl-support.core :refer :all]
            [adl-support.utils :refer :all]
            [adl.to-hugsql-queries :refer [generate-documentation queries]]
            [clj-time.core :as t]
            [clj-time.format :as f]
            [clojure.java.io :refer [file make-parents writer]]
            [clojure.pprint :refer [pprint]]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;; adl.to-cache: generate caching layer for database requests.
;;;;
;;;; This program is free software; you can redistribute it and/or
;;;; modify it under the terms of the GNU General Public License
;;;; as published by the Free Software Foundation; either version 2
;;;; of the License, or (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
;;;; USA.
;;;;
;;;; Copyright (C) 2018 Simon Brooke
;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; You can't cache the actual HugSQL functions (or at least, I don't know how
;;; you would); there's no point caching JSON requests because the request data
;;; will be different every time.

;;; The overall structure of this has quite closely to follow the structure of
;;; to-hugsql-queries, because essentially we need one JSON entry point to wrap
;;; each query.

;;; TODO: memoisation of handlers probably doesn't make sense, because every request
;;; will be different. I don't think we can memoise HugSQL, at least not without
;;; hacking the library (might be worth doing that and contributing a patch).
;;; So the solution may be to an intervening namespace 'cache', which has one
;;; memoised function for each hugsql query.

(defn file-header
  "Generate an appropriate file header for JSON routes for this `application`."
  [application]
  (list
    'ns
    (symbol (str (safe-name (:name (:attrs application))) ".cache"))
    (str "Caching wrappers for queries for " (:name (:attrs application))
         " auto-generated by [Application Description Language framework](https://github.com/simon-brooke/adl) at "
         (f/unparse (f/formatters :basic-date-time) (t/now)))
    (list
      :require
      '[adl-support.core :refer :all]
      '[adl-support.rest-support :refer :all]
      '[clojure.core.memoize :as memo]
      '[clojure.java.io :as io]
      '[clojure.tools.logging :as log]
      '[compojure.core :refer [defroutes GET POST]]
      '[hugsql.core :as hugsql]
      '[noir.response :as nresponse]
      '[noir.util.route :as route]
      '[ring.util.http-response :as response]
      (vector (symbol (str (safe-name (:name (:attrs application))) ".db.core")) :as 'db))))


(defn handler
  "Generate declarations for handlers for this `query`. Cache handlers are needed only for select queries."
  [query]
  (let [handler-name (symbol (:name query))
        v (volatility (:entity query))]
    (if (and
          (number? v)
          (> v 0)
          (#{:select-1 :select-many :text-search}(:type query)))
      (list
        'def
        handler-name
        (str
          "Auto-generated function to "
          (generate-documentation query))
        (list
          'memo/ttl
          (list
            'fn
            ['connection 'params]
            (list
              (symbol (str "db/" (:name query)))
              'connection 'params))
          {}
          :ttl/threshold
          (* v 1000))))))


(defn to-cache
  "Generate a `/cache.clj` file for this `application`."
  [application]
  (let [queries-map (queries application)
        filepath (str *output-path* "src/clj/" (:name (:attrs application)) "/cache.clj")]
    (make-parents filepath)
    (do-or-warn
      (with-open [output (writer filepath)]
        (binding [*out* output]
          (pprint (file-header application))
          (println)
          (doall
            (map
              (fn [k]
                (let [k (handler (queries-map k))]
                  (if k
                    (do
                      (pprint k)
                      (println)))
                  k))
              (sort (keys queries-map)))))))
    (if (pos? *verbosity*)
      (*warn* (str "\tGenerated " filepath)))))

