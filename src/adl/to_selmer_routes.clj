(ns ^{:doc "Application Description Language: generate routes for user interface requests."
      :author "Simon Brooke"}
  adl.to-selmer-routes
  (:require [adl-support.utils :refer :all]
            [clojure.java.io :refer [file make-parents writer]]
            [clojure.pprint :refer [pprint]]
            [clojure.string :as s]
            [clojure.xml :as x]
            [clj-time.core :as t]
            [clj-time.format :as f]
            ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;; adl.to-selmer-routes: generate routes for user interface requests.
;;;;
;;;; This program is free software; you can redistribute it and/or
;;;; modify it under the terms of the GNU General Public License
;;;; as published by the Free Software Foundation; either version 2
;;;; of the License, or (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
;;;; USA.
;;;;
;;;; Copyright (C) 2018 Simon Brooke
;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Generally. there's one route in the generated file for each Selmer
;;; template which has been generated.

;;; TODO: there must be some more idiomatic way of generating all these
;;; functions.

(defn file-header
  [application]
  (list
    'ns
    (symbol (str (:name (:attrs application)) ".routes.auto"))
    (str "User interface routes for " (pretty-name application)
         " auto-generated by [Application Description Language framework](https://github.com/simon-brooke/adl) at "
         (f/unparse (f/formatters :basic-date-time) (t/now)))
    (list
      :require
      '[adl-support.core :as support]
      '[clojure.java.io :as io]
      '[compojure.core :refer [defroutes GET POST]]
      '[hugsql.core :as hugsql]
      '[noir.response :as nresponse]
      '[noir.util.route :as route]
      '[ring.util.http-response :as response]
      (vector (symbol (str (:name (:attrs application)) ".layout")) :as 'l)
      (vector (symbol (str (:name (:attrs application)) ".db.core")) :as 'db)
      (vector (symbol (str (:name (:attrs application)) ".routes.manual")) :as 'm))))

(defn make-handler
  [f e a]
  (let [n (path-part f e a)]
    (list
      'defn
      (symbol n)
      (vector 'r)
      (list 'let (vector
                   'p
                   (list 'merge
                         {:offset 0 :limit 25}
                         (list 'support/massage-params (list :params 'r))))
            ;; TODO: we must take key params out of just params,
            ;; but we should take all other params out of form-params - because we need the key to
            ;; load the form in the first place, but just accepting values of other params would
            ;; allow spoofing.
            (list
              'l/render
              (list 'support/resolve-template (str n ".html"))
              '(:session r)
              (merge
                {:title (capitalise (:name (:attrs f)))
                 :params  'p}
                (case (:tag f)
                  (:form :page)
                  (reduce
                    merge
                    {:record
                     ;; TODO: this breaks. We need to check for the presence of the
                     ;; actual key in the params.
                     (list 'if (list 'empty? (list 'remove 'nil? (list 'vals 'p))) []
                           (list
                             (symbol
                               (str "db/get-" (singularise (:name (:attrs e)))))
                             (symbol "db/*db*")
                             'p))}
                    (map
                      (fn [p]
                        (hash-map
                          (keyword (-> p :attrs :entity))
                          (list (symbol (str "db/list-" (:entity (:attrs p)))) (symbol "db/*db*"))))
                      (filter #(#{"entity" "link"} (:type (:attrs %)))
                              (descendants-with-tag e :property))))
                  :list
                  {:records
                   (list
                     'if
                     (list
                       'not
                       (list
                         'empty?
                         (list 'remove 'nil? (list 'vals 'p))))
                     (list
                       (symbol
                         (str
                           "db/search-strings-"
                           (singularise (:name (:attrs e)))))
                       (symbol "db/*db*")
                       'p)
                     (list
                       (symbol
                         (str
                           "db/list-"
                           (:name (:attrs e))))
                       (symbol "db/*db*") {}))})))))))

(defn make-route
  "Make a route for method `m` to request the resource with name `n`."
  [m n]
  (list
    m
    (str "/" n)
    'request
    (list
      'route/restricted
      (list
        'apply
        (list 'resolve-handler n)
        (list 'list 'request)))))

(defn make-defroutes
  [application]
  (let [routes (flatten
                 (map
                   (fn [e]
                     (map
                       (fn [c]
                         (path-part c e application))
                       (filter (fn [c] (#{:form :list :page} (:tag c))) (children e))))
                   (children-with-tag application :entity)))]
    (cons
      'defroutes
      (cons
        'auto-selmer-routes
        (cons
          '(GET
             "/admin"
             request
             (route/restricted
               (apply (resolve-handler "index") (list request))))
          (interleave
            (map
              (fn [r] (make-route 'GET r))
              (sort routes))
            (map
              (fn [r] (make-route 'POST r))
              (sort routes))))))))


(defn generate-handler-resolver
  "Dodgy, dodgy, dodgy. Generate code which will look up functions in the
  manual and in this namespace. I'm sure someone who really knew what they
  were doing could write this more elegantly."
  [application]
  (list
    'defn
    'raw-resolve-handler
    "Prefer the manually-written version of the handler with name `n`, if it exists, to the automatically generated one"
    (vector 'n)
    (list 'try
          (list 'eval (list 'symbol (list 'str (:name (:attrs application)) ".routes.manual/" 'n)))
          (list 'catch
                'Exception '_
                (list 'eval
                      (list 'symbol
                            (list 'str (:name (:attrs application)) ".routes.auto/" 'n)))))))


(defn to-selmer-routes
  [application]
  (let [filepath (str *output-path* "src/clj/" (:name (:attrs application)) "/routes/auto.clj")]
    (make-parents filepath)
    (try
      (with-open [output (writer filepath)]
        (binding [*out* output]
          (pprint (file-header application))
          (println)
          (pprint '(defn index
                     [r]
                     (l/render
                       (support/resolve-template
                         "application-index.html")
                       (:session r)
                       {:title "Administrative menu"})))
          (println)
          (doall
            (map
              (fn [e]
                (doall
                  (map
                    (fn [c]
                      (pprint (make-handler c e application))
                      (println))
                    (filter (fn [c] (#{:form :list :page} (:tag c))) (children e)))))
              (sort
                #(compare (:name (:attrs %1))(:name (:attrs %2)))
                (children-with-tag application :entity))))
          (pprint
            (generate-handler-resolver application))
          (println)
          (pprint '(def resolve-handler
                     (memoize raw-resolve-handler)))
          (println)
          (pprint (make-defroutes application))
          (println)))
      (if (> *verbosity* 0)
        (println (str "\tGenerated " filepath)))
      (catch
        Exception any
        (println
          (str
            "ERROR: Exception "
            (.getName (.getClass any))
            (.getMessage any)
            " while printing "
            filepath))))))

