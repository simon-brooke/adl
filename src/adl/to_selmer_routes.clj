(ns ^{:doc "Application Description Language: generate routes for user interface requests."
      :author "Simon Brooke"}
  adl.to-selmer-routes
  (:require [clojure.java.io :refer [file make-parents writer]]
            [clojure.pprint :refer [pprint]]
            [clojure.string :as s]
            [clojure.xml :as x]
            [clj-time.core :as t]
            [clj-time.format :as f]
            [adl.utils :refer :all]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;; adl.to-selmer-routes: generate RING routes for REST requests.
;;;;
;;;; This program is free software; you can redistribute it and/or
;;;; modify it under the terms of the GNU General Public License
;;;; as published by the Free Software Foundation; either version 2
;;;; of the License, or (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
;;;; USA.
;;;;
;;;; Copyright (C) 2018 Simon Brooke
;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Generally. there's one route in the generated file for each Selmer template which has been generated.

(def ^:dynamic *output-path*
  "The path to which generated files will be written."
  "resources/auto/")


(defn file-header
  [application]
  (list
    'ns
    (symbol (str (:name (:attrs application)) ".routes.auto"))
    (str "JSON routes for " (pretty-name application)
         " auto-generated by [Application Description Language framework](https://github.com/simon-brooke/adl) at "
         (f/unparse (f/formatters :basic-date-time) (t/now)))
    (list
      :require
      '[noir.response :as nresponse]
      '[noir.util.route :as route]
      '[compojure.core :refer [defroutes GET POST]]
      '[ring.util.http-response :as response]
      '[clojure.java.io :as io]
      '[hugsql.core :as hugsql]
      (vector (symbol (str (:name (:attrs application)) ".routes.manual")) :as 'm))))

(defn make-handler
  [f e a]
  (let [n (path-part f e a)]
    (list
      'defn
      (symbol n)
      (vector 'r)
      (list
        'layout/render
        (list 'resolve-template (str n ".html")) {:title (pretty-name e)}))))

(defn make-route
  "Make a route for method `m` to request the resource with name `n`."
  [m n]
  (list
    m
    (str "/" n)
    'request
    (list
      'route/restricted
      (list
        'apply
        (list 'resolve-handler n)
        (list 'list 'request)))))

(defn make-defroutes
  [application]
  (let [routes (flatten
                 (map
                   (fn [e]
                     (map
                       (fn [c]
                         (path-part c e application))
                       (filter (fn [c] (#{:form :list :page} (:tag c))) (children e))))
                   (children-with-tag application :entity)))]
    (cons
      'defroutes
      (cons
        'auto-selmer-routes
        (interleave
          (map
            (fn [r] (make-route 'GET r))
            (sort routes))
        (map
          (fn [r] (make-route 'POST r))
          (sort routes)))))))


(defn to-selmer-routes
  [application]
  (let [filename (str *output-path* (:name (:attrs application)) "/routes/auto.clj")]
    (make-parents filename)
    (with-open [output (writer filename)]
      (binding [*out* output]
        (pprint (file-header application))
        (println)
        (pprint '(defn raw-resolve-template [n]
                   (if
                     (.exists (io/as-file (str "resources/templates/" n)))
                     n
                     (str "auto/" n))))
        (println)
        (pprint '(def resolve-template (memoise raw-resolve-template)))
        (println)
        (doall
          (map
            (fn [e]
              (doall
                (map
                  (fn [c]
                    (pprint (make-handler c e application))
                    (println))
                  (filter (fn [c] (#{:form :list :page} (:tag c))) (children e)))))
            (children-with-tag application :entity)))
        (pprint '(defn raw-resolve-handler
                   "Prefer the manually-written version of the handler with name `n`, if it exists, to the automatically generated one"
                   [n]
                   (let [s (symbol (str "m." n))]
                     (if
                       (bound? s)
                       (eval s)
                       (eval (symbol n))))))
        (println)
        (pprint '(def resolve-handler
                   (memoize raw-resolve-handler)))
        (println)
        (pprint (make-defroutes application))
        (println)))))

(def x (x/parse "../youyesyet/youyesyet.canonical.adl.xml"))

(to-selmer-routes x)

