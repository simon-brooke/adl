(ns ^{:doc "Application Description Language: generate RING routes for REST requests."
      :author "Simon Brooke"}
  adl.to-json-routes
  (:require [adl-support.core :refer :all]
            [adl-support.utils :refer :all]
            [adl.to-hugsql-queries :refer [generate-documentation queries]]
            [clj-time.core :as t]
            [clj-time.format :as f]
            [clojure.java.io :refer [file make-parents writer]]
            [clojure.pprint :refer [pprint]]
            [clojure.string :as s]
            [clojure.xml :as x]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;; adl.to-json-routes: generate RING routes for REST requests.
;;;;
;;;; This program is free software; you can redistribute it and/or
;;;; modify it under the terms of the GNU General Public License
;;;; as published by the Free Software Foundation; either version 2
;;;; of the License, or (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
;;;; USA.
;;;;
;;;; Copyright (C) 2018 Simon Brooke
;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; The overall structure of this has quite closely to follow the structure of
;;; to-hugsql-queries, because essentially we need one JSON entry point to wrap
;;; each query.

;;; TODO: memoisation of handlers probably doesn't make sense, because every request
;;; will be different. I don't think we can memoise HugSQL, at least not without
;;; hacking the library (might be worth doing that and contributing a patch).
;;; So the solution may be to an intervening namespace 'cache', which has one
;;; memoised function for each hugsql query.

(defn file-header
  "Generate an appropriate file header for JSON routes for this `application`."
  [application]
  (list
    'ns
    (symbol (str (safe-name (:name (:attrs application))) ".routes.auto-json"))
    (str "JSON routes for " (:name (:attrs application))
         " auto-generated by [Application Description Language framework](https://github.com/simon-brooke/adl) at "
         (f/unparse (f/formatters :basic-date-time) (t/now)))
    (list
      :require
      '[adl-support.core :refer :all]
      '[adl-support.rest-support :refer :all]
      '[clojure.core.memoize :as memo]
      '[clojure.java.io :as io]
      '[clojure.tools.logging :as log]
      '[compojure.core :refer [defroutes GET POST]]
      '[hugsql.core :as hugsql]
      '[noir.response :as nresponse]
      '[noir.util.route :as route]
      '[ring.util.http-response :as response]
      (vector (symbol (str (safe-name (:name (:attrs application))) ".cache")) :as 'cache)
      (vector (symbol (str (safe-name (:name (:attrs application))) ".db.core")) :as 'db))))


(defn declarations
  "Generate a forward declaration of all JSON route handlers we're going to
  generate for this `application`."
  [handlers-map]
  (cons 'declare (sort (map #(symbol (name %)) (keys handlers-map)))))


(defn generate-handler-body
  "Generate and return the function body for the handler for this `query`."
  [query]
  (list
    ['request]
    (let
      [v (volatility (:entity query))
       function (symbol (str
                          (if
                            (and
                              (number? v)
                              (> v 0)
                              (#{:select-1 :select-many :text-search} (:type query)))
                            "cache"
                            "db")
                          "/"
                          (:name query)))]

      (list
        'let
        ['params (list
                   'merge
                   (apply hash-map
                          (interleave
                            (map
                              #(keyword (column-name %))
                              (descendants-with-tag
                                (:entity query)
                                :property
                                #(not (= (-> % :attrs :required) "true"))))
                            (repeat nil)))
                   '(massage-params request))]
        (list
          'valid-user-or-forbid
          (list
            'with-params-or-error
            (list
              'do-or-server-fail
              (list
                function
                'db/*db* 'params)
              (case (:type query)
                :insert-1 201 ;; created
                :delete-1 204 ;; no content
                ;; default
                200)) ;; OK
            'params
            (set
              (map
                #(keyword (column-name %))
                (case (:type query)
                  :insert-1
                  (-> query :entity required-properties)
                  :update-1 (concat
                              (-> query :entity key-properties)
                              (-> query :entity required-properties))
                  (:select-1 :delete-1)
                  (-> query :entity key-properties)
                  ;; default
                  nil))))
          'request)))))


(defn generate-handler-src
  "Generate and return the handler for this `query`."
  [handler-name query-map method]
  (let [doc (str
              "Auto-generated function to "
              (generate-documentation query-map))
        v (volatility (:entity query-map))]
    (hash-map
      :method method
      :src (remove
             nil?
             (concat
               (list
                 'defn
                 handler-name
                 doc
                 (generate-handler-body query-map)))))))


(defn handler
  "Generate declarations for handlers from query with this `query-key` in this `queries-map`
  taken from within this `application`. This method must follow the structure of
  `to-hugsql-queries/queries` quite closely, because we must generate the same names."
  [query-key queries-map application]
  (let [query (query-key queries-map)
        handler-name (symbol (name query-key))]
    (hash-map
      (keyword handler-name)
      (merge
        {:name handler-name
         :route (str "/json/" handler-name)}
        (case
          (:type query)
          (:delete-1 :insert-1 :update-1)
          (generate-handler-src
            handler-name query :post)
          (:select-1 :select-many :text-search)
          (generate-handler-src
            handler-name query :get)
          (:select-many-to-many
            :select-one-to-many)
          (hash-map :method :get
                    :src (list 'defn handler-name [{:keys ['params]}]
                               (list 'do (list (symbol (str "db/" (:name query))) 'params))))
          ;; default
          (hash-map
            :src
            (str ";; don't know what to do with query `" :key "` of type `" (:type query) "`.")))))))


(defn make-handlers-map
  "Analyse this `application` and generate from it a map of the handlers to be output."
  [application]
  (reduce
    merge
    {}
    (map
      (fn [e]
        (let [qmap (queries application e)]
          (reduce
            merge
            {}
            (map
              (fn [k]
                (handler k qmap application))
              (keys qmap)))))
      (children-with-tag application :entity))))


(defn defroutes
  "Generate JSON routes for all queries implied by this ADL `application` spec."
  [handlers-map]
  (cons
    'defroutes
    (cons
      'auto-rest-routes
      (map
        #(let [handler (handlers-map %)]
           (list
             (symbol (s/upper-case (name (:method handler))))
             (str "/json/auto/" (safe-name (:name handler)))
             'request
             (list
               'route/restricted
               (list (:name handler) 'request))))
        (sort
          (keys handlers-map))))))


(defn to-json-routes
  "Generate a `/routes/auto-json.clj` file for this `application`."
  [application]
  (let [handlers-map (make-handlers-map application)
        filepath (str *output-path* "src/clj/" (:name (:attrs application)) "/routes/auto_json.clj")]
    (make-parents filepath)
    (do-or-warn
      (with-open [output (writer filepath)]
        (binding [*out* output]
          (pprint (file-header application))
          (println)
          (doall
            (map
              (fn [h]
                (pprint (:src (handlers-map h)))
                (println)
                h)
              (sort (keys handlers-map))))
          (pprint (defroutes handlers-map)))))
    (if (pos? *verbosity*)
      (*warn* (str "\tGenerated " filepath)))))


