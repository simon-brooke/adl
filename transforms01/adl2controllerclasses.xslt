<?xml version="1.0" encoding="UTF-8"?>

  <!--
    Application Description Language framework
    adl2controllerclasses.xsl
    
    (c) 2007 Cygnet Solutions Ltd
    
    Transform ADL into (partial) controller classes
    
    $Author: sb $
    $Revision: 1.5 $
    $Date: 2008-02-11 16:13:17 $
  -->

  <!-- WARNING WARNING WARNING: Do NOT reformat this file! 
     Whitespace (or lack of it) is significant! -->
<xsl:stylesheet version="1.0"
  xmlns="http://cygnets.co.uk/schemas/adl-1.2" 
  xmlns:adl="http://cygnets.co.uk/schemas/adl-1.2"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

  <xsl:include href="csharp-type-include.xslt"/>

  <xsl:output encoding="UTF-8" method="text"/>

  <!-- The locale for which these controllers are generated 
      TODO: Controllers should NOT be locale specific. Instead, the
      controller should render views and generate messages based on the 
      client's locale. However, there may still need to be a concept of a
      'default locale', for when we don't have messages which suit the
      client's locale -->
    <xsl:param name="locale" select="en-UK"/>

    <!-- The C# namespace within which I shall generate controllers -->
    <xsl:param name="controllerns" select="Unset"/>
    <!-- The C# namespace used by the entities for this project -->
    <xsl:param name="entityns" select="Unset"/>
    <!-- Whether to authenticate at application or at database layer. 
    If not 'Application', then 'Database'. -->
    <xsl:param name="authentication-layer" select="Application"/>

    <!-- 
      The convention to use for naming auto-generated abstract primary keys. Known values are
      Id - the autogenerated primary key, if any, is called just 'Id'
      Name - the autogenerated primary key has the same name as the entity
      NameId - the name of the auto generated primary key is the name of the entity followed by 'Id'
      Name_Id - the name of the auto generated primary key is the name of the entity followed by '_Id'  
    -->
    <xsl:param name="abstract-key-name-convention" select="Id"/>

    <xsl:template match="adl:application">
      <xsl:apply-templates select="adl:entity"/>
    </xsl:template>

    <!-- Don't bother generating anything for foreign entities -->
    <xsl:template match="adl:entity[@foreign='true']"/>
  
    <xsl:template match="adl:entity[adl:form|adl:page|adl:list]">
      <!-- what's all this about? the objective is to get the revision number of the 
    transform into the output, /without/ getting that revision number overwritten 
    with the revision number of the generated file if the generated file is 
    stored to CVS -->
      <xsl:variable name="transform-rev1"
                    select="substring( '$Revision: 1.5 $', 11)"/>
      <xsl:variable name="transform-revision"
                    select="substring( $transform-rev1, 0, string-length( $transform-rev1) - 1)"/>

      <xsl:variable name="key">
        <xsl:call-template name="primary-key-name">
          <xsl:with-param name="entity" select="."/>
        </xsl:call-template>
      </xsl:variable>

      /* ---- [ cut here: next file '<xsl:value-of select="@name"/>Controller.auto.cs'] ---------------- */

//------------------------------------------------------------------
//
//  Application Description Framework
//  <xsl:value-of select="@name"/>Controller.auto.cs
//
// (c) 2007 Cygnet Solutions Ltd
//
//  Controller for auto-generated forms for editing <xsl:value-of select="@name"/>s
//  Automatically generated from application description using
//  adl2controllerclass.xsl version <xsl:value-of select="$transform-revision"/>
//
//  This file is automatically generated; DO NOT EDIT IT.
//
//------------------------------------------------------------------

using System;
using System.Data;
using System.Collections.Generic;
using System.Configuration;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;
using Castle.MonoRail.Framework.Helpers;
using Cygnet.Exceptions;
using Cygnet.Web.Helpers;
using Cygnet.Web.Controllers;
using NHibernate;
using NHibernate.Expression;
using Castle.MonoRail.Framework;
using Iesi.Collections.Generic;
using <xsl:value-of select="$entityns"/>;

namespace <xsl:value-of select="$controllerns"/> {

  /// &lt;summary&gt;
  /// Automatically generated partial controller class following 'thin controller'
  /// strategy, for entity <xsl:value-of select="@name"/>. Note that part of this
  /// class may be defined in a separate file called 
  /// <xsl:value-of select="@name"/>Controller.manual.cs, q.v.
  ///
  /// DO NOT EDIT THIS FILE!
  /// &lt;/summary&gt;
  public partial class <xsl:value-of select="@name"/>Controller : BaseController {

      <xsl:if test="adl:form">
        <!-- unless there's at least one form, we won't generate a 'store' method -->
      /// &lt;summary&gt;
      /// Store the record represented by the parameters passed in an HTTP service
      /// Without Id -&gt; it's new, I create a new persistent object;
      /// With Id -&gt; it's existing, I update the existing persistent object.
      /// NOTE: Should only be called from a handler for method 'POST', never 'GET'.
      /// &lt;/summary&gt;
      private void Store()
      {
        ISession hibernator = 
          NHibernateHelper.GetCurrentSession( <xsl:if test="$authentication-layer = 'Database'">Session[ NHibernateHelper.USERTOKEN], 
                                              Session[NHibernateHelper.PASSTOKEN]</xsl:if>);
          List&lt;string&gt; messages = new List&lt;string&gt;();

        <xsl:value-of select="$entityns"/>.<xsl:value-of select="@name"/> record;

        <xsl:apply-templates select="adl:property"/>

        <!-- TODO: this does not corectly handle entities with composite primary keys -->
        string id = Form["<xsl:value-of select="concat( 'instance.', $key)"/>"];

        if ( String.IsNullOrEmpty( id))
        {
          /* it's new, create persistent object */
          record = new <xsl:value-of select="$entityns"/>.<xsl:value-of select="@name"/>(<xsl:for-each select="adl:property[@distinct='system']">Form[<xsl:value-of select="concat( 'instance.', @name)"/>]<xsl:choose>
                <xsl:when test="position() = last()"/>
                <xsl:otherwise>, </xsl:otherwise>
              </xsl:choose>
            </xsl:for-each>);

          /* perform any domain knowledge behaviour on the new record 
           * after instantiation */
          record.AfterCreationHook( hibernator);
          messages.Add( "New <xsl:value-of select="@name"/> record created");
        }
        else
        {
          /* it's existing, retrieve it */
        <!-- TODO: this does not correctly handle entities with composite primary keys -->
          record =
            hibernator.CreateCriteria(typeof(<xsl:value-of select="concat( $entityns, '.', @name)"/>))
              .Add(Expression.Eq("<xsl:value-of select="$key"/>", id)
              .UniqueResult&lt;<xsl:value-of select="concat( $entityns, '.', @name)"/>&gt;();
        }

        if ( record != null)
        {
          try
          {
            /* actually update the record */
            BindObjectInstance( record, ParamStore.Form, "instance");
            
            <xsl:for-each select="adl:property[@type='entity']">
            /* for properties of type 'entity', it should not be necessary to do anything 
             * special - BindObjectInstance /should/ do it all. Unfortunately it sometimes 
             * doesn't, and I haven't yet characterised why not. */
             <!-- TODO: Fix this! -->
              <xsl:variable name="linkkeytype">
                <xsl:call-template name="primary-key-csharp-type">
                  <xsl:with-param name="entity" select="//entity[@name=@entity]"/>
                </xsl:call-template>
              </xsl:variable>
            record.<xsl:value-of select="@name"/> = 
              hibernator.CreateCriteria(typeof(<xsl:value-of select="concat( $entityns, '.', @entity)"/>))
                .Add(Expression.Eq("<xsl:call-template name="primary-key-name">
                  <xsl:with-param name="entity" select="//entity[@name=@entity]"/>
                </xsl:call-template>", ((<xsl:value-of select="$linkkeytype"/>)Form["<xsl:value-of select="concat( $entityns, '.', @entity)"/>"])))
                .UniqueResult&lt;<xsl:value-of select="concat( $entityns, '.', @entity)"/>&gt;();
            </xsl:for-each>
          
            <xsl:for-each select="property[@type='link']">  
            /* to update a link table which has no other data than the near and far keys, it is
             * sufficient to smash the existing values and create new ones. It's also a lot easier! */
        
            string[] <xsl:value-of select="concat(@name, 'Values')"/> = Form.GetValues( "<xsl:value-of select="concat( 'instance.', @name)"/>");
          
            if ( <xsl:value-of select="concat(@name, 'Values')"/> != null)
            {
              /* update the linking table for my <xsl:value-of select="@name"/>; first smash the old values */
              if ( <xsl:value-of select="concat( 'record.', @name)"/> != null)
              {
                <xsl:value-of select="concat( 'record.', @name)"/>.Clear();
              }
              else
              {
                <xsl:value-of select="concat( 'record.', @name)"/> = new HashedSet&lt;<xsl:value-of select="@entity"/>&gt;();
              }
            
              /* then reinstate the values from the indexes passed */
              foreach ( string index in <xsl:value-of select="concat(@name, 'Values')"/>)
              {
                <xsl:value-of select="concat( 'record.', @name)"/>.Add(
                  hibernator.CreateCriteria(typeof(<xsl:value-of select="@entity"/>))
                    .Add(Expression.Eq("<xsl:value-of select="@entity"/>Id", index))
                    .UniqueResult&lt;<xsl:value-of select="$entityns"/>.<xsl:value-of select="@entity"/>&gt;());
              }
            }
            </xsl:for-each>

            <xsl:for-each select="adl:property[@type='list']">
            /* with a list we cannot just smash the old values! Instead we need to check 
             * each one and exclude it if no longer required */
            if ( Form.GetValues( "<xsl:value-of select="concat( 'instance.', @name)"/>") != null)
            {
              string[] <xsl:value-of select="concat(@name, 'Values')"/> = Form.GetValues( "<xsl:value-of select="concat( 'instance.', @name)"/>");

              /* updating <xsl:value-of select="@name"/> child records; first remove any not on the submitted list */
              foreach ( <xsl:value-of select="@entity"/> item in record.<xsl:value-of select="@name"/>)
              {
                String itemId = item.KeyString;
                bool found = false;

                foreach ( string index in <xsl:value-of select="concat(@name, 'Values')"/>)
                {
                  <!-- TODO: this could definitely be made more efficient -->
                  if ( index.Equals( itemId))
                  {
                    found = true;
                  }
                }
          
                if ( ! found)
                {
                  record.<xsl:value-of select="@name"/>.Remove( item);
                }
              }

              /* then add any on the included list which are not already members */
              foreach ( string index in <xsl:value-of select="concat(@name, 'Values')"/>)
              {
                <xsl:variable name="entityname" select="@entity"/>
                <xsl:value-of select="@entity"/> item = 
                  hibernator.CreateCriteria(typeof(<xsl:value-of select="@entity"/>))
                    .Add(Expression.Eq("<xsl:value-of select="@entity"/>Id", ((<xsl:call-template name="primary-key-csharp-type">
                      <xsl:with-param name="entity" select="//adl:entity[@name=$entityname]"/> 
                    </xsl:call-template>)index)))
                    .UniqueResult&lt;<xsl:value-of select="$entityns"/>.<xsl:value-of select="@entity"/>&gt;();
              
                if ( ! record.<xsl:value-of select="@name"/>.Contains( item))
                {
                  record.<xsl:value-of select="@name"/>.Add( item);
                }
              }
            }
            </xsl:for-each>

            /* perform any domain knowledge behaviour on the record prior to updating */
            record.BeforeUpdateHook( hibernator);

            /* write the record to the database, in order to guarantee we have a valid key */
            hibernator.Save(record);
            hibernator.Flush();

            /* perform any domain knowledge behaviour on the record after updating */
            record.AfterUpdateHook( hibernator);
        
            messages.Add( "Record saved successfully");
          }
          catch ( DataSuitabilityException dse)
          {
            AddError( dse.Message);
          }
          catch ( ApplicationException axe)
          {
            AddError( axe.Message);
          }

          PropertyBag["messages"] = messages;
          PropertyBag["instance"] = record;    
            <xsl:if test="$authentication-layer = 'Database'">   
          PropertyBag["username"] = Session[ NHibernateHelper.USERTOKEN];
            </xsl:if>
      
            <xsl:call-template name="menus">
              <xsl:with-param name="entity" select="."/>
            </xsl:call-template>
          RenderViewWithFailover("<xsl:value-of select="concat( adl:form[position()=1]/@name, '.vm')"/>", 
              "<xsl:value-of select="concat( adl:form[position()=1]/@name, '.auto.vm')"/>");
        }
        else
        {
          throw new Exception( String.Format( "No record of type <xsl:value-of select="@name"/> with key value {0} found", id));
        }
      }
      </xsl:if>

      <xsl:if test="adl:form">
        <!-- unless there's at least one form, we won't generate a 'delete' method -->
      /// &lt;summary&gt;
      /// Actually delete the selected record
      /// &lt;/summary&gt;
      [AccessibleThrough(Verb.Get)]
      public void Delete()
      {
        ISession hibernator = 
            NHibernateHelper.GetCurrentSession( <xsl:if test="$authentication-layer = 'Database'">Session[ NHibernateHelper.USERTOKEN], 
                                                Session[NHibernateHelper.PASSTOKEN]</xsl:if>);
        string id = Params["<xsl:value-of select="concat( 'instance.', $key)"/>"];
        string reallydelete = Params["reallydelete"];
        
        if ( "true".Equals( reallydelete))
        { 
          <xsl:value-of select="concat($entityns, '.', @name)"/> record =
            hibernator.CreateCriteria(typeof(<xsl:value-of select="concat($entityns, '.', @name)"/>))
              .Add(Expression.Eq("<xsl:value-of select="$key"/>", ((<xsl:call-template name="primary-key-csharp-type">
                <xsl:with-param name="entity" select="."/>
              </xsl:call-template>)))
              .UniqueResult&lt;<xsl:value-of select="concat($entityns, '.', @name)"/>&gt;();

          if ( record != null)
          {
            record.BeforeDeleteHook( hibernator);

            hibernator.Delete( 
              hibernator.CreateCriteria(typeof(<xsl:value-of select="concat($entityns, '.', @name)"/>))
                .Add(Expression.Eq("<xsl:value-of select="$key"/>", ((<xsl:call-template name="primary-key-csharp-type">
                  <xsl:with-param name="entity" select="."/>
                </xsl:call-template>)id)))
                .UniqueResult&lt;<xsl:value-of select="concat($entityns, '.', @name)"/>&gt;());

            hibernator.Flush();
          }
          else
          {
            throw new ApplicationException( "No such record?");
          }
        }
        <xsl:choose>
          <xsl:when test="adl:list">
        InternalShowList();
          </xsl:when>
          <xsl:otherwise>
        Redirect( FormsAuthentication.DefaultUrl);
          </xsl:otherwise>
        </xsl:choose>
      }
      </xsl:if>
      <xsl:apply-templates select="adl:form"/>

      <xsl:if test="adl:list">
        <xsl:variable name="listname" select="adl:list[position()=1]/@name"/>
        <xsl:apply-templates select="adl:list"/>
      /// &lt;summary&gt;
      /// list all instances of this entity to allow the user to select one for editing
      /// this method invokes the default list view - which is probably what you want unless
      /// you've a special reason for doing something different
      /// &lt;/summary&gt;
      public void InternalShowList()
      {
        InternalShowList( "<xsl:value-of select="$listname"/>");
      }

      /// &lt;summary&gt;
      /// list all instances of this entity to allow the user to select one for editing
      /// &lt;/summary&gt;
      /// &lt;param name="view"&gt;The name of the list view to show&lt;/param&gt;
      public void InternalShowList( String view)
      {
        ISession hibernator = 
          NHibernateHelper.GetCurrentSession( <xsl:if test="$authentication-layer = 'Database'">Session[ NHibernateHelper.USERTOKEN], 
                                              Session[NHibernateHelper.PASSTOKEN]</xsl:if>);
        IList&lt;<xsl:value-of select="@name"/>&gt; instances = 
          hibernator.CreateCriteria(typeof(<xsl:value-of select="concat($entityns, '.', @name)"/>))<xsl:for-each select="property[@distinct='user']">
            <xsl:value-of select="concat( '.AddOrder( new Order( &#34;', @name, '&#34;, true))')"/>
          </xsl:for-each>.List&lt;<xsl:value-of select="concat($entityns, '.', @name)"/>&gt;();

        <xsl:if test="$authentication-layer = 'Database'">
        PropertyBag["username"] = Session[ NHibernateHelper.USERTOKEN];
        </xsl:if>
        PropertyBag["instances"] =
        PaginationHelper.CreatePagination( this, instances, 25);

        RenderViewWithFailover(view + ".vm", view + ".auto.vm");
      }
      </xsl:if>
  }
}
    </xsl:template>

    <xsl:template match="adl:property[@required='true']">
        if ( Form[ "<xsl:value-of select="concat( 'instance.', @name)"/>" ] == null)
        {
          AddError( <xsl:choose>
        <xsl:when test="ifmissing[@locale=$locale]">
          <xsl:apply-templates select="ifmissing[@locale=$locale]"/>
        </xsl:when>
        <xsl:otherwise>"You must supply a value for <xsl:value-of select="@name"/>"</xsl:otherwise>
      </xsl:choose>);
        }

    </xsl:template>

    <!-- suppress properties otherwise -->
    <xsl:template match="adl:property"/>
        
    <xsl:template match="adl:ifmissing">
      "<xsl:value-of select="normalize-space(.)"/>"
    </xsl:template>

    <xsl:template match="adl:form">
      <xsl:variable name="key">
        <xsl:call-template name="primary-key-name">
          <xsl:with-param name="entity" select="ancestor::adl:entity"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:variable name="keytype">
        <xsl:call-template name="primary-key-csharp-type">
          <xsl:with-param name="entity" select="ancestor::adl:entity"/>
        </xsl:call-template>
      </xsl:variable>
      /// &lt;summary&gt;
      /// Handle the submission of the form named <xsl:value-of select="@name"/>
      /// &lt;/summary&gt;
      [AccessibleThrough(Verb.Post)]
      public void <xsl:value-of select="concat( @name, 'SubmitHandler')"/>( )
      {
      string command = Form[ "command"];

      if ( command == null)
      {
      throw new Exception( "No command?");
      }
      else
      <xsl:for-each select=".//verb">
        if ( command.Equals( "<xsl:value-of select="@verb"/>"))
        {
          /* NOTE: You must write an implementation of this verb in a
            manually maintained partial class file for this class */
          <xsl:value-of select="@verb"/>();
        }
        else
        </xsl:for-each>
        if ( command.Equals( "delete"))
        {
          ISession hibernator = 
            NHibernateHelper.GetCurrentSession( <xsl:if test="$authentication-layer = 'Database'">Session[ NHibernateHelper.USERTOKEN], 
                                                Session[NHibernateHelper.PASSTOKEN]</xsl:if>);
          string id = Form["<xsl:value-of select="concat( 'instance.', $key)"/>"];

      <xsl:if test="$authentication-layer = 'Database'">   
          PropertyBag["username"] = Session[ NHibernateHelper.USERTOKEN];
      </xsl:if>
          PropertyBag["instance"] = 
            hibernator.CreateCriteria(typeof(<xsl:value-of select="concat($entityns, '.', ancestor::adl:entity/@name)"/>))
              .Add(Expression.Eq("<xsl:value-of select="$key"/>", id))
              .UniqueResult&lt;<xsl:value-of select="concat($entityns, '.', ancestor::adl:entity/@name)"/>&gt;();
          
          RenderViewWithFailover( "maybedelete.vm", "maybedelete.auto.vm");
        }
        else if ( command.Equals( "store"))
        {
          Store();
        }
        else
        {
          throw new Exception( String.Format("Unrecognised command '{0}'", command));
        }
      }
            
      /// &lt;summary&gt;
      /// Show the form named <xsl:value-of select="@name"/>, with no content
      /// &lt;/summary&gt;
      [AccessibleThrough(Verb.Get)]
      public void <xsl:value-of select="@name"/>( )
      {
        ISession hibernator = 
          NHibernateHelper.GetCurrentSession( <xsl:if test="$authentication-layer = 'Database'">Session[ NHibernateHelper.USERTOKEN], 
                                              Session[NHibernateHelper.PASSTOKEN]</xsl:if>);
      <xsl:call-template name="menus">
        <xsl:with-param name="entity" select="ancestor::adl:entity"/>
      </xsl:call-template>

      <xsl:if test="$authentication-layer = 'Database'">   
        PropertyBag["username"] = Session[ NHibernateHelper.USERTOKEN];
      </xsl:if>
        RenderViewWithFailover("<xsl:value-of select="concat( @name, '.vm')"/>", 
          "<xsl:value-of select="concat( @name, '.auto.vm')"/>");
      }

      /// &lt;summary&gt;
      /// Show the form named <xsl:value-of select="@name"/>, containing the indicated record 
      /// &lt;/summary&gt;
      /// &lt;param name="<xsl:value-of select="concat( ../@name, 'Id')"/>"&gt;the key value of the record to show&lt;/param&gt;
      [AccessibleThrough(Verb.Get)]
      public void <xsl:value-of select="@name"/>( <xsl:value-of select="$keytype"/> <xsl:value-of select="concat( ../@name, 'Id')"/>)
      {
        ISession hibernator = 
          NHibernateHelper.GetCurrentSession( <xsl:if test="$authentication-layer = 'Database'">Session[ NHibernateHelper.USERTOKEN], 
                                              Session[NHibernateHelper.PASSTOKEN]</xsl:if>);
        <xsl:value-of select="concat($entityns, '.', ancestor::adl:entity/@name)"/> record =
          hibernator.CreateCriteria(typeof(<xsl:value-of select="concat($entityns, '.', ancestor::adl:entity/@name)"/>))
            .Add(Expression.Eq("<xsl:value-of select="$key"/>", <xsl:value-of select="../@name"/>Id))
            .UniqueResult&lt;<xsl:value-of select="concat($entityns, '.', ancestor::adl:entity/@name)"/>&gt;();

      <xsl:if test="$authentication-layer = 'Database'">   
        PropertyBag["username"] = Session[ NHibernateHelper.USERTOKEN];
      </xsl:if>
        PropertyBag["instance"] = record;

      <xsl:call-template name="menus">
        <xsl:with-param name="entity" select=".."/>
      </xsl:call-template>
        RenderViewWithFailover("<xsl:value-of select="concat( @name, '.vm')"/>", "<xsl:value-of select="concat( @name, '.auto.vm')"/>");
      }

    </xsl:template>

    <xsl:template match="adl:list">
      /// &lt;summary&gt;
      /// list all instances of this entity to allow the user to select one
      /// this method invokes the named view.
      /// &lt;/summary&gt;
      public void <xsl:value-of select="@name"/>()
      {
        InternalShowList( "<xsl:value-of select="@name"/>");
      }

    </xsl:template>

    <xsl:template match="adl:documentation">
      /* <xsl:apply-templates/> */
    </xsl:template>

    <xsl:template name="menus">
      <xsl:param name="entity"/>
      <xsl:for-each select="$entity/adl:property[@type='entity']">
          /* produce a list of <xsl:value-of select="@entity"/> to populate the menu for <xsl:value-of select="@name"/> */
        <xsl:call-template name="menu">
          <xsl:with-param name="property" select="."/>
        </xsl:call-template>

      </xsl:for-each>
      <xsl:for-each select="$entity/adl:property[@type='link']">
          /* produce a list of <xsl:value-of select="@entity"/> to populate the LHS of the shuffle for <xsl:value-of select="@name"/> */
        <xsl:call-template name="menu">
          <xsl:with-param name="property" select="."/>
        </xsl:call-template>
      </xsl:for-each>
      <xsl:for-each select="$entity/adl:property[@type='list']">
          /* produce a list of <xsl:value-of select="@entity"/> to populate the multi-select for <xsl:value-of select="@name"/> */
        <xsl:call-template name="menu">
          <xsl:with-param name="property" select="."/>
        </xsl:call-template>
      </xsl:for-each>

    </xsl:template>

    <xsl:template name="menu">
      <xsl:param name="property"/>
      <xsl:variable name="ename" select="$property/@entity"/>
      <xsl:variable name="entity" select="//adl:entity[@name=$ename]"/>
          PropertyBag["<xsl:value-of select="concat('all_', $property/@name)"/>"] =
            hibernator.CreateCriteria(typeof(<xsl:value-of select="concat( $entityns, '.', $property/@entity)"/>))<xsl:for-each select="$entity/property[@distinct='user']">
              <xsl:value-of select="concat('.AddOrder( new Order( &#34;', @name, '&#34;, true))')"/>
            </xsl:for-each>.List&lt;<xsl:value-of select="concat( $entityns, '.', $property/@entity)"/>&gt;();
    </xsl:template>

  <xsl:template name="primary-key-csharp-type">
    <xsl:param name="entity"/>
    <xsl:if test="not($entity/adl:key/adl:property)">
      <xsl:message terminate="yes">
        ADL: ERROR: entity '<xsl:value-of select="$entity/@name"/>' has no primary key.
      </xsl:message>
    </xsl:if>
    <xsl:call-template name="csharp-type">
      <xsl:with-param name="property">
        <xsl:value-of select="$entity/adl:key/adl:property[ position() = 1]"/>
      </xsl:with-param>
    </xsl:call-template>
  </xsl:template>
  
    <xsl:template name="primary-key-name">
      <!-- return the name of the primary key of the entity with this name -->
      <xsl:param name="entity"/>
      <xsl:choose>
        <xsl:when test="$entity/@natural-key">
          <xsl:value-of select="$entity/@natural-key"/>
        </xsl:when>
        <xsl:when test="$entity/key">
          <xsl:choose>
            <xsl:when test="count($entity/adl:key/adl:property) &gt; 1">
              <xsl:message terminate="no">
                ADL: WARNING: entity '<xsl:value-of select="$entity/@name"/>' has a compound primary key;
                adl2controllerclasses is not yet clever enough to generate appropriate code.
              </xsl:message>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="$entity/adl:key/adl:property[position()=1]"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>
        <xsl:otherwise>
          <xsl:choose>
            <xsl:when test="$abstract-key-name-convention='Name'">
              <xsl:value-of select="@name"/>
            </xsl:when>
            <xsl:when test="$abstract-key-name-convention = 'NameId'">
              <xsl:value-of select="concat( $entity/@name, 'Id')"/>
            </xsl:when>
            <xsl:when test="$abstract-key-name-convention = 'Name_Id'">
              <xsl:value-of select="concat( $entity/@name, '_Id')"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="'Id'"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:template>
  </xsl:stylesheet>