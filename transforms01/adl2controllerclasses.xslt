<?xml version="1.0" encoding="UTF-8"?>

  <!--
    Application Description Language framework
    adl2controllerclasses.xsl
    
    (c) 2007 Cygnet Solutions Ltd
    
    Transform ADL into (partial) controller classes
    
    $Author: sb $
    $Revision: 1.14 $
    $Date: 2008-03-10 17:01:26 $
  -->

  <!-- WARNING WARNING WARNING: Do NOT reformat this file! 
     Whitespace (or lack of it) is significant! -->
<xsl:stylesheet version="1.0"
  xmlns="http://cygnets.co.uk/schemas/adl-1.2" 
  xmlns:adl="http://cygnets.co.uk/schemas/adl-1.2"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

  <xsl:include href="csharp-type-include.xslt"/>

  <xsl:output encoding="UTF-8" method="text"/>

  <!-- The locale for which these controllers are generated 
      TODO: Controllers should NOT be locale specific. Instead, the
      controller should render views and generate messages based on the 
      client's locale. However, there may still need to be a concept of a
      'default locale', for when we don't have messages which suit the
      client's locale -->
    <xsl:param name="locale" select="en-UK"/>

    <!-- The C# namespace within which I shall generate controllers -->
    <xsl:param name="controllerns" select="Unset"/>
    <!-- The C# namespace used by the entities for this project -->
    <xsl:param name="entityns" select="Unset"/>
    <!-- Whether to authenticate at application or at database layer. 
    If not 'Application', then 'Database'. -->
    <xsl:param name="authentication-layer" select="Application"/>
    <!-- 
      The convention to use for naming auto-generated abstract primary keys. Known values are
      Id - the autogenerated primary key, if any, is called just 'Id'
      Name - the autogenerated primary key has the same name as the entity
      NameId - the name of the auto generated primary key is the name of the entity followed by 'Id'
      Name_Id - the name of the auto generated primary key is the name of the entity followed by '_Id'  
    -->
    <xsl:param name="abstract-key-name-convention" select="Id"/>

    <xsl:template match="adl:application">
      <xsl:apply-templates select="adl:entity"/>
    </xsl:template>

    <!-- Don't bother generating anything for foreign entities -->
    <xsl:template match="adl:entity[@foreign='true']"/>
  
    <xsl:template match="adl:entity[adl:form|adl:page|adl:list]">
      <!-- what's all this about? the objective is to get the revision number of the 
    transform into the output, /without/ getting that revision number overwritten 
    with the revision number of the generated file if the generated file is 
    stored to CVS -->
      <xsl:variable name="transform-rev1"
                    select="substring( '$Revision: 1.14 $', 11)"/>
      <xsl:variable name="transform-revision"
                    select="substring( $transform-rev1, 0, string-length( $transform-rev1) - 1)"/>

      <!-- xsl:variable name="key">
        <xsl:call-template name="primary-key-name">
          <xsl:with-param name="entity" select="."/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:variable name="keytype">
        <xsl:choose>
          <xsl:when test="adl:key/adl:property">
            <xsl:call-template name="primary-key-csharp-type">
              <xsl:with-param name="entity" select="."/>
            </xsl:call-template>
          </xsl:when>
          <xsl:otherwise>[no primary key]</xsl:otherwise>
        </xsl:choose>
      </xsl:variable -->


      /* ---- [ cut here: next file '<xsl:value-of select="@name"/>Controller.auto.cs'] ---------------- */

//------------------------------------------------------------------
//
//  Application Description Language framework
//  <xsl:value-of select="@name"/>Controller.auto.cs
//
// (c) 2007 Cygnet Solutions Ltd
//
//  Controller for auto-generated forms for editing <xsl:value-of select="@name"/>s
//  Automatically generated from application description using
//  adl2controllerclasses.xslt version <xsl:value-of select="$transform-revision"/>
//
//  This file is automatically generated; DO NOT EDIT IT.
//
//------------------------------------------------------------------

using System;
using System.Data;
using System.Collections.Generic;
using System.Configuration;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;
using Castle.MonoRail.Framework.Helpers;
using Cygnet.Exceptions;
using Cygnet.Web.Helpers;
using Cygnet.Web.Controllers;
using NHibernate;
using NHibernate.Expression;
using Castle.MonoRail.Framework;
using Iesi.Collections.Generic;
using <xsl:value-of select="$entityns"/>;

namespace <xsl:value-of select="$controllerns"/> {

  /// &lt;summary&gt;
  /// Automatically generated partial controller class following 'thin controller'
  /// strategy, for entity <xsl:value-of select="@name"/>. Note that part of this
  /// class may be defined in a separate file called 
  /// <xsl:value-of select="@name"/>Controller.manual.cs, q.v.
  ///
  /// DO NOT EDIT THIS FILE!
  /// &lt;/summary&gt;
  [ Layout("empty"), Rescue("generalerror"), 
    ControllerDetails("<xsl:value-of select="@name"/>", Area = "auto")]
  public partial class <xsl:value-of select="@name"/>Controller : BaseController {

      <xsl:if test="adl:form">
        <!-- unless there's at least one form, we won't generate a 'store' method -->
      /// &lt;summary&gt;
      /// Store the record represented by the parameters passed in an HTTP service
      /// Without Id -&gt; it's new, I create a new persistent object;
      /// With Id -&gt; it's existing, I update the existing persistent object.
      /// NOTE: Should only be called from a handler for method 'POST', never 'GET'.
      /// &lt;/summary&gt;
      private void Store()
      {
        ISession hibernator = 
          NHibernateHelper.GetCurrentSession( <xsl:if test="$authentication-layer = 'Database'">Session[ NHibernateHelper.USERTOKEN], 
                                              Session[NHibernateHelper.PASSTOKEN]</xsl:if>);
        List&lt;string&gt; messages = new List&lt;string&gt;();
        
        <xsl:apply-templates select="descendant::adl:property"/>

        <xsl:call-template name="fetch-instance">
          <xsl:with-param name="entity" select="."/>
        </xsl:call-template>

        if ( record == null) {
          /* it seems to be new, create persistent object */
          try {
            record = new <xsl:value-of select="concat($entityns, '.', @name)"/>(<xsl:for-each select="adl:key/adl:property">
          <xsl:variable name="basetype">
            <xsl:call-template name="base-type">
              <xsl:with-param name="property" select="."/>
            </xsl:call-template>
          </xsl:variable>
          <xsl:choose>
            <xsl:when test="$basetype='integer'">Int32.Parse( Form["<xsl:value-of select="concat( 'instance.', @name)"/>"])</xsl:when>
            <xsl:when test="$basetype='entity'">
              <!-- Maybe TODO: this doesn't work recursively - if an entity has a key which is an entity 
                  and the key of that entity is an entity, you're on your own, mate! -->
              <xsl:variable name="keyentity" select="@entity"/>
              <xsl:variable name="keyenttype">
                <xsl:call-template name="primary-key-csharp-type">
                  <xsl:with-param name="entity" select="//adl:entity[@name=$keyentity]"/>
                </xsl:call-template>
              </xsl:variable>
                hibernator.CreateCriteria( typeof( <xsl:value-of select="concat( $entityns, '.', $keyentity)"/>))
                  .Add(Expression.Eq( "<xsl:value-of select="//adl:entity[@name=$keyentity]/adl:key/adl:property[position()=1]/@name"/>",<xsl:choose>
                <xsl:when test="$keyenttype = 'int'">Int32.Parse( Form[ "<xsl:value-of select="concat( 'instance.', @name)"/>"])</xsl:when>
                <xsl:otherwise>Form[ "<xsl:value-of select="concat( 'instance.', @name)"/>"]</xsl:otherwise>
              </xsl:choose>))
                  .UniqueResult&lt;<xsl:value-of select="concat( $entityns, '.', $keyentity)"/>&gt;()</xsl:when>
            <xsl:otherwise>Form["<xsl:value-of select="concat( 'instance.', @name)"/>"]</xsl:otherwise>
          </xsl:choose>
          <xsl:choose>
            <xsl:when test="position() = last()"/>
            <xsl:otherwise>, </xsl:otherwise>
          </xsl:choose>
        </xsl:for-each>);
          }
          catch ( FormatException) {
            /* failed to parse a number - not wholly unexpected, since it's most likely 
            that an empty string was passed in */
            record = new <xsl:value-of select="concat($entityns, '.', @name)"/>();
          }
          catch ( NullReferenceException) {
            /* again, probably more normal than otherwise */
            record = new <xsl:value-of select="concat($entityns, '.', @name)"/>();
          }
          /* perform any domain knowledge behaviour on the new record
           * after instantiation */
          record.AfterCreationHook( hibernator);
          messages.Add( "New <xsl:value-of select="@name"/> record created");
        }

        if ( record != null) {
          try {
            /* actually update the record */
            BindObjectInstance( record, ParamStore.Form, "instance");

        <xsl:if test="descendant::adl:property[@type='message']">
            /* there is at least one slot whose value is an internationalised message; 
             * if these have yet to be initialised they must be handled specially */
            Locale locale = GetBestLocaleForUser();
          <xsl:for-each select="descendant::adl:property[@type='message']">
            if ( ! String.IsNullOrEmpty( Form["<xsl:value-of select="concat( 'i18n.instance.', @name)"/>"])){
              /* there's an uninitialised message for this slot */
              Message mess = record.<xsl:value-of select="@name"/>;
              if ( mess == null){
                mess = new Message();
              }
              hibernator.Save( mess);

              Translation trans = mess.GetTranslationObject( locale, hibernator);
              if ( trans == null) {
                trans = new Translation( mess, locale);
              }
              trans.MessageText = Form["<xsl:value-of select="concat( 'i18n.instance.', @name)"/>"];
              record.<xsl:value-of select="@name"/> = mess;
              hibernator.Save( trans);
            }
          </xsl:for-each>
        </xsl:if>

        <xsl:for-each select="descendant::adl:property[@type='entity']">
            /* for properties of type 'entity', it should not be necessary to do anything 
             * special - BindObjectInstance /should/ do it all. Unfortunately it sometimes 
             * doesn't, and I haven't yet characterised why not. */
              <xsl:variable name="entityname" select="@entity"/>
              <xsl:choose>
                <xsl:when test="//adl:entity[@name=$entityname]">
            if ( ! String.IsNullOrEmpty( Form["<xsl:value-of select="concat( 'instance.', @name)"/>"]))
            {
              record.<xsl:value-of select="@name"/> = <xsl:call-template name="fetch-property-instance">
                <xsl:with-param name="property" select="."/>
                <xsl:with-param name="valuename" select="concat( 'instance.', @name)"/>
              </xsl:call-template>;
            }
                </xsl:when>
                <xsl:otherwise>
                  <xsl:message terminate="yes">
                    ADL: ERROR: Could not fix up value of <xsl:value-of select="@name "/>, because no
                    entity was found called <xsl:value-of select="$entityname"/>
                  </xsl:message>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:for-each>

                <xsl:for-each select="property[@type='link']">  
            /* to update a link table which has no other data than the near and far keys, it is
             * sufficient to smash the existing values and create new ones. It's also a lot easier! */
        
            string[] <xsl:value-of select="concat(@name, 'Values')"/> = Form.GetValues( "<xsl:value-of select="concat( 'instance.', @name)"/>");
          
            if ( <xsl:value-of select="concat(@name, 'Values')"/> != null)
            {
              /* update the linking table for my <xsl:value-of select="@name"/>; first smash the old values */
              if ( <xsl:value-of select="concat( 'record.', @name)"/> != null)
              {
                <xsl:value-of select="concat( 'record.', @name)"/>.Clear();
              }
              else
              {
                <xsl:value-of select="concat( 'record.', @name)"/> = new HashedSet&lt;<xsl:value-of select="@entity"/>&gt;();
              }
            
              /* then reinstate the values from the indexes passed */
              foreach ( string index in <xsl:value-of select="concat(@name, 'Values')"/>)
              {
                <xsl:value-of select="concat( 'record.', @name)"/>.Add(
                  hibernator.CreateCriteria(typeof(<xsl:value-of select="@entity"/>))
                    .Add(Expression.Eq("<xsl:value-of select="@entity"/>Id", index))
                    .UniqueResult&lt;<xsl:value-of select="$entityns"/>.<xsl:value-of select="@entity"/>&gt;());
              }
            }
            </xsl:for-each>

            <xsl:for-each select="descendant::adl:property[@type='list']">
            /* with a list we cannot just smash the old values! Instead we need to check 
             * each one and exclude it if no longer required */
            if ( Form.GetValues( "<xsl:value-of select="concat( 'instance.', @name)"/>") != null)
            {
              string[] <xsl:value-of select="concat(@name, 'Values')"/> = Form.GetValues( "<xsl:value-of select="concat( 'instance.', @name)"/>");

              /* updating <xsl:value-of select="@name"/> child records; first remove any not on the submitted list */
              foreach ( <xsl:value-of select="@entity"/> item in record.<xsl:value-of select="@name"/>)
              {
                String itemId = item.KeyString;
                bool found = false;

                foreach ( string index in <xsl:value-of select="concat(@name, 'Values')"/>)
                {
                  <!-- TODO: this could definitely be made more efficient -->
                  if ( index.Equals( itemId))
                  {
                    found = true;
                  }
                }
          
                if ( ! found)
                {
                  record.<xsl:value-of select="@name"/>.Remove( item);
                }
              }

              /* then add any on the included list which are not already members */
              foreach ( string index in <xsl:value-of select="concat(@name, 'Values')"/>)
              {
                <xsl:variable name="entityname" select="@entity"/>
                <xsl:value-of select="@entity"/> item = 
                  hibernator.CreateCriteria(typeof(<xsl:value-of select="@entity"/>))
                    .Add(Expression.Eq("<xsl:value-of select="@entity"/>Id", index))
                    .UniqueResult&lt;<xsl:value-of select="$entityns"/>.<xsl:value-of select="@entity"/>&gt;();
              
                if ( ! record.<xsl:value-of select="@name"/>.Contains( item))
                {
                  record.<xsl:value-of select="@name"/>.Add( item);
                }
              }
            }
            </xsl:for-each>

            /* perform any domain knowledge behaviour on the record prior to updating */
            record.BeforeUpdateHook( hibernator);

            /* write the record to the database, in order to guarantee we have a valid key */
            hibernator.Save(record);
            hibernator.Flush();

            /* perform any domain knowledge behaviour on the record after updating */
            record.AfterUpdateHook( hibernator);
        
            messages.Add( "Record saved successfully");
          }
          catch ( DataSuitabilityException dse)
          {
            AddError( dse.Message);
          }
          catch ( ApplicationException axe)
          {
            AddError( axe.Message);
          }

          PropertyBag["messages"] = messages;
          PropertyBag["instance"] = record;    
            <xsl:if test="$authentication-layer = 'Database'">   
          PropertyBag["username"] = Session[ NHibernateHelper.USERTOKEN];
            </xsl:if>
        
          if ( ! AssertNoErrors())
          {
            /* the session may be polluted; create a new session */
            NHibernateHelper.CloseSession();
            hibernator = NHibernateHelper.GetCurrentSession(<xsl:if test="$authentication-layer = 'Database'">
        Session[ NHibernateHelper.USERTOKEN],
        Session[NHibernateHelper.PASSTOKEN]
      </xsl:if>);
          }

      <xsl:call-template name="menus">
              <xsl:with-param name="entity" select="."/>
            </xsl:call-template>
          RenderViewWithFailover("<xsl:value-of select="concat( adl:form[position()=1]/@name, '.vm')"/>", 
              "<xsl:value-of select="concat( adl:form[position()=1]/@name, '.auto.vm')"/>");
        }
        else
        {
          throw new DataRequiredException( "Record not found");
        }
      }
      </xsl:if>

      <xsl:if test="adl:form">
        <!-- unless there's at least one form, we won't generate a 'delete' method -->
      /// &lt;summary&gt;
      /// Actually delete the selected record
      /// &lt;/summary&gt;
      [AccessibleThrough(Verb.Post)]
      public void Delete()
      {
        ISession hibernator = 
            NHibernateHelper.GetCurrentSession( <xsl:if test="$authentication-layer = 'Database'">Session[ NHibernateHelper.USERTOKEN], 
                                                Session[NHibernateHelper.PASSTOKEN]</xsl:if>);

        string reallydelete = Params["reallydelete"];

        if ( "true".Equals( reallydelete))
        {
        <xsl:call-template name="fetch-instance">
          <xsl:with-param name="entity" select="."/>
        </xsl:call-template>

          if ( record != null)
          {
            record.BeforeDeleteHook( hibernator);

            hibernator.Delete( record);

            hibernator.Flush();
          }
          else
          {
            throw new ApplicationException( "No such record?");
          }
        }
        <xsl:choose>
          <xsl:when test="adl:list">
        InternalShowList();
          </xsl:when>
          <xsl:otherwise>
        Redirect( FormsAuthentication.DefaultUrl);
          </xsl:otherwise>
        </xsl:choose>
      }
      </xsl:if>
      <xsl:apply-templates select="adl:form"/>

      <xsl:if test="adl:list">
        <xsl:variable name="listname" select="adl:list[position()=1]/@name"/>
        <xsl:apply-templates select="adl:list"/>
      /// &lt;summary&gt;
      /// list all instances of this entity to allow the user to select one for editing
      /// this method invokes the default list view - which is probably what you want unless
      /// you've a special reason for doing something different
      /// &lt;/summary&gt;
      public void InternalShowList()
      {
        InternalShowList( "<xsl:value-of select="$listname"/>");
      }

      /// &lt;summary&gt;
      /// list all instances of this entity to allow the user to select one for editing
      /// &lt;/summary&gt;
      /// &lt;param name="view"&gt;The name of the list view to show&lt;/param&gt;
      public void InternalShowList( String view)
      {
        ISession hibernator = 
          NHibernateHelper.GetCurrentSession( <xsl:if test="$authentication-layer = 'Database'">Session[ NHibernateHelper.USERTOKEN], 
                                              Session[NHibernateHelper.PASSTOKEN]</xsl:if>);
        IList&lt;<xsl:value-of select="concat( $entityns, '.', @name)"/>&gt; instances = 
          hibernator.CreateCriteria(typeof(<xsl:value-of select="concat($entityns, '.', @name)"/>))<xsl:for-each select="property[@distinct='user']">
            <xsl:value-of select="concat( '.AddOrder( new Order( &#34;', @name, '&#34;, true))')"/>
          </xsl:for-each>.List&lt;<xsl:value-of select="concat($entityns, '.', @name)"/>&gt;();

        <xsl:if test="$authentication-layer = 'Database'">
        PropertyBag["username"] = Session[ NHibernateHelper.USERTOKEN];
        </xsl:if>
        PropertyBag["instances"] =
        PaginationHelper.CreatePagination( this, instances, 25);

        RenderViewWithFailover(view + ".vm", view + ".auto.vm");
      }
      </xsl:if>
  }
}
    </xsl:template>

    <xsl:template match="adl:property[@required='true']">
        if ( Form[ "<xsl:value-of select="concat( 'instance.', @name)"/>" ] == null)
        {
          AddError( <xsl:choose>
        <xsl:when test="adl:ifmissing[@locale=$locale]">
          <xsl:apply-templates select="adl:ifmissing[@locale=$locale]"/>
        </xsl:when>
        <xsl:otherwise>"You must supply a value for <xsl:value-of select="@name"/>"</xsl:otherwise>
      </xsl:choose>);
        }

    </xsl:template>

    <!-- suppress properties otherwise -->
    <xsl:template match="adl:property"/>
        
    <xsl:template match="adl:ifmissing">
      "<xsl:value-of select="normalize-space(.)"/>"
    </xsl:template>

    <xsl:template match="adl:form">
      <!-- xsl:variable name="key">
        <xsl:call-template name="primary-key-name">
          <xsl:with-param name="entity" select="ancestor::adl:entity"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:variable name="keytype">
        <xsl:call-template name="primary-key-csharp-type">
          <xsl:with-param name="entity" select="ancestor::adl:entity"/>
        </xsl:call-template>
      </xsl:variable -->
      /// &lt;summary&gt;
      /// Handle the submission of the form named <xsl:value-of select="@name"/>
      /// &lt;/summary&gt;
      [AccessibleThrough(Verb.Post)]
      public void <xsl:value-of select="concat( @name, 'SubmitHandler')"/>( )
      {
        string command = Form[ "command"];

        if ( command == null)
        {
          throw new Exception( "No command?");
        }
        else
      <xsl:for-each select=".//verb">
        if ( command.Equals( "<xsl:value-of select="@verb"/>"))
        {
          /* NOTE: You must write an implementation of this verb in a
            manually maintained partial class file for this class */
          <xsl:value-of select="@verb"/>();
        }
        else
        </xsl:for-each>
        if ( command.Equals( "delete"))
        {
          ISession hibernator = 
            NHibernateHelper.GetCurrentSession( <xsl:if test="$authentication-layer = 'Database'">Session[ NHibernateHelper.USERTOKEN], 
                                                Session[NHibernateHelper.PASSTOKEN]</xsl:if>);

      <xsl:call-template name="fetch-instance">
        <xsl:with-param name="entity" select="ancestor::adl:entity"/>
      </xsl:call-template>

      <xsl:if test="$authentication-layer = 'Database'">   
          PropertyBag["username"] = Session[ NHibernateHelper.USERTOKEN];
      </xsl:if>
          PropertyBag["instance"] = record;
          
          RenderViewWithFailover( "maybedelete.vm", "maybedelete.auto.vm");
        }
        else if ( command.Equals( "store"))
        {
          Store();
        }
        else
        {
          throw new Exception( String.Format("Unrecognised command '{0}'", command));
        }
      }
            
      /// &lt;summary&gt;
      /// Show the form named <xsl:value-of select="@name"/>, with no content
      /// &lt;/summary&gt;
      [AccessibleThrough(Verb.Get)]
      public void <xsl:value-of select="@name"/>( )
      {
        ISession hibernator = 
          NHibernateHelper.GetCurrentSession( <xsl:if test="$authentication-layer = 'Database'">Session[ NHibernateHelper.USERTOKEN], 
                                              Session[NHibernateHelper.PASSTOKEN]</xsl:if>);
      <xsl:call-template name="menus">
        <xsl:with-param name="entity" select="ancestor::adl:entity"/>
      </xsl:call-template>

      <xsl:if test="$authentication-layer = 'Database'">   
        PropertyBag["username"] = Session[ NHibernateHelper.USERTOKEN];
      </xsl:if>
        RenderViewWithFailover("<xsl:value-of select="concat( @name, '.vm')"/>", 
          "<xsl:value-of select="concat( @name, '.auto.vm')"/>");
      }
      
    <xsl:if test="ancestor::adl:entity/adl:key/adl:property[@type='entity']">
        <!-- if there's a key which is an entity, the actual entity can't be passed in. 
        So what will be passed in is the key value, from which we can find the entity -->

      /// &lt;summary&gt;
      /// Show the form named <xsl:value-of select="@name"/>, containing the indicated record. As
      /// the primary key of the record is itself an entity, we need to first fetch that entity
      /// &lt;/summary&gt;
      <xsl:for-each select="ancestor::adl:entity/adl:key/adl:property">
        <xsl:choose>
          <xsl:when test="@type='entity'">
      /// &lt;param name="<xsl:value-of select="concat( @name, '_Value')"/>"&gt;the key value of the key value of the record to show&lt;/param&gt;
          </xsl:when>
          <xsl:otherwise>
      /// &lt;param name="<xsl:value-of select="@name"/>"&gt;the key value of the record to show&lt;/param&gt;
          </xsl:otherwise>
        </xsl:choose>
      </xsl:for-each>
      [AccessibleThrough(Verb.Get)]
      public void <xsl:value-of select="@name"/>( <xsl:for-each select="ancestor::adl:entity/adl:key/adl:property">
        <xsl:choose>
          <xsl:when test="@type='entity'">
            <xsl:call-template name="csharp-base-type">
              <xsl:with-param name="property" select="."/>
            </xsl:call-template>
            <xsl:value-of select="concat( ' ', @name, '_Value')"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:call-template name="csharp-base-type">
              <xsl:with-param name="property" select="."/>
            </xsl:call-template>
            <xsl:value-of select="concat( ' ', @name)"/>
          </xsl:otherwise>
        </xsl:choose>
        <xsl:if test="not( position() = last())">,</xsl:if>
      </xsl:for-each>) {
        ISession hibernator = 
          NHibernateHelper.GetCurrentSession( <xsl:if test="$authentication-layer = 'Database'">Session[ NHibernateHelper.USERTOKEN], 
                                              Session[NHibernateHelper.PASSTOKEN]</xsl:if>);
        this.<xsl:value-of select="@name"/>( <xsl:for-each select="ancestor::adl:entity/adl:key/adl:property">
        <xsl:choose>
          <xsl:when test="@type='entity'">
            <xsl:variable name="entity" select="@entity"/> 
            hibernator.CreateCriteria(typeof(<xsl:value-of select="concat($entityns, '.', @entity)"/>))
              .Add( Expression.Eq( "<xsl:value-of select="//adl:entity[@name=$entity]/adl:key/adl:property[position()=1]/@name"/>", <xsl:value-of select="concat( @name, '_Value')"/>))
              .UniqueResult&lt;<xsl:value-of select="concat($entityns, '.', @entity)"/>&gt;()
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="concat( ' ', @name)"/>
          </xsl:otherwise>
        </xsl:choose>
        <xsl:if test="not( position() = last())">,</xsl:if>
      </xsl:for-each>);
      }
    </xsl:if>

      /// &lt;summary&gt;
      /// Show the form named <xsl:value-of select="@name"/>, containing the indicated record 
      /// &lt;/summary&gt;
      <xsl:for-each select="ancestor::adl:entity/adl:key/adl:property">
      /// &lt;param name="<xsl:value-of select="@name"/>"&gt;the key value of the record to show&lt;/param&gt;
      </xsl:for-each>
      [AccessibleThrough(Verb.Get)]
      public void <xsl:value-of select="@name"/>( <xsl:for-each select="ancestor::adl:entity/adl:key/adl:property">
        <xsl:call-template name="csharp-type">
          <xsl:with-param name="property" select="."/>
        </xsl:call-template>
        <xsl:value-of select="concat( ' ', @name)"/>
        <xsl:if test="not( position() = last())">,</xsl:if>
      </xsl:for-each>)
      {
        ISession hibernator = 
          NHibernateHelper.GetCurrentSession( <xsl:if test="$authentication-layer = 'Database'">Session[ NHibernateHelper.USERTOKEN], 
                                              Session[NHibernateHelper.PASSTOKEN]</xsl:if>);
        <xsl:value-of select="concat($entityns, '.', ancestor::adl:entity/@name)"/> record =
          hibernator.CreateCriteria(typeof(<xsl:value-of select="concat($entityns, '.', ancestor::adl:entity/@name)"/>))
          <xsl:for-each select="ancestor::adl:entity/adl:key/adl:property">
            .Add(Expression.Eq("<xsl:value-of select="@name"/>", <xsl:value-of select="@name"/>))
          </xsl:for-each>
            .UniqueResult&lt;<xsl:value-of select="concat($entityns, '.', ancestor::adl:entity/@name)"/>&gt;();

      <xsl:if test="$authentication-layer = 'Database'">   
        PropertyBag["username"] = Session[ NHibernateHelper.USERTOKEN];
      </xsl:if>
        PropertyBag["instance"] = record;

      <xsl:call-template name="menus">
        <xsl:with-param name="entity" select=".."/>
      </xsl:call-template>
        RenderViewWithFailover("<xsl:value-of select="concat( @name, '.vm')"/>", "<xsl:value-of select="concat( @name, '.auto.vm')"/>");
      }

    </xsl:template>

    <xsl:template match="adl:list">
      /// &lt;summary&gt;
      /// list all instances of this entity to allow the user to select one
      /// this method invokes the named view.
      /// &lt;/summary&gt;
      public void <xsl:value-of select="@name"/>()
      {
        InternalShowList( "<xsl:value-of select="@name"/>");
      }

    </xsl:template>

    <xsl:template match="adl:documentation">
      /* <xsl:apply-templates/> */
    </xsl:template>

    <xsl:template name="menus">
      <xsl:param name="entity"/>
      <xsl:for-each select="$entity/adl:property[@type='entity']">
          /* produce a list of <xsl:value-of select="@entity"/> to populate the menu for <xsl:value-of select="@name"/> */
        <xsl:call-template name="menu">
          <xsl:with-param name="property" select="."/>
        </xsl:call-template>

      </xsl:for-each>
      <xsl:for-each select="$entity/adl:property[@type='link']">
          /* produce a list of <xsl:value-of select="@entity"/> to populate the LHS of the shuffle for <xsl:value-of select="@name"/> */
        <xsl:call-template name="menu">
          <xsl:with-param name="property" select="."/>
        </xsl:call-template>
      </xsl:for-each>
      <xsl:for-each select="$entity/adl:property[@type='list']">
          /* produce a list of <xsl:value-of select="@entity"/> to populate the multi-select for <xsl:value-of select="@name"/> */
        <xsl:call-template name="menu">
          <xsl:with-param name="property" select="."/>
        </xsl:call-template>
      </xsl:for-each>

    </xsl:template>

  <xsl:template match="adl:key">
    <!-- the key shouldn't be matched directly - at least, not in this implementation -->
  </xsl:template>

    <xsl:template name="menu">
      <xsl:param name="property"/>
      <xsl:variable name="ename" select="$property/@entity"/>
      <xsl:variable name="entity" select="//adl:entity[@name=$ename]"/>
          PropertyBag["<xsl:value-of select="concat('all_', $property/@name)"/>"] =
            hibernator.CreateCriteria(typeof(<xsl:value-of select="concat( $entityns, '.', $property/@entity)"/>))<xsl:for-each select="$entity/property[@distinct='user']">
              <xsl:value-of select="concat('.AddOrder( new Order( &#34;', @name, '&#34;, true))')"/>
            </xsl:for-each>.List&lt;<xsl:value-of select="concat( $entityns, '.', $property/@entity)"/>&gt;();
    </xsl:template>

  <xsl:template name="primary-key-csharp-type">
    <xsl:param name="entity"/>
    <xsl:if test="not( $entity)">
      <xsl:message terminate="yes">
        ADL: ERROR: No entity passed to template primary-key-csharp-type
      </xsl:message>
    </xsl:if>
    <xsl:if test="not($entity/adl:key/adl:property)">
      <xsl:message terminate="no">
        ADL: WARNING: entity '<xsl:value-of select="$entity/@name"/>' has no primary key.
        You will have to manually edit <xsl:value-of select="concat( $entity/@name, 'Controller.auto.cs')"/>
      </xsl:message>
    </xsl:if>
    <xsl:call-template name="csharp-type">
      <xsl:with-param name="property" select="$entity/adl:key/adl:property[ position() = 1]"/>
      <xsl:with-param name="entityns" select="$entityns"/>
    </xsl:call-template>
  </xsl:template>
  
    <xsl:template name="primary-key-name">
      <!-- return the name of the primary key of the entity with this name -->
      <xsl:param name="entity"/>
      <xsl:if test="not($entity/adl:key)">
        <xsl:message terminate="yes">
          ADL: ERROR: No key for entity: <xsl:value-of select="$entity/@name"/>
        </xsl:message>
      </xsl:if>
      <xsl:choose>
        <xsl:when test="$entity/adl:key/adl:property[position()=2]">
          <xsl:message terminate="no">
            ADL: WARNING: Entity <xsl:value-of select="$entity/@name"/> has a composite primary key.
            You will need to manually edit <xsl:value-of select="concat( $entity/@name, 'Controller.auto.cs')"/>
          </xsl:message>
          <xsl:value-of select="$entity/adl:key/adl:property[position()=1]/@name"/>
        </xsl:when>
        <xsl:when test="$entity/adl:key/adl:property">
          <xsl:value-of select="$entity/adl:key/adl:property[position()=1]/@name"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:message terminate="no">
            ADL: WARNING: Entity <xsl:value-of select="$entity/@name"/> has no primary key.
            You will need to manually edit <xsl:value-of select="concat( $entity/@name, 'Controller.auto.cs')"/>
          </xsl:message>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:template>

  <xsl:template name="fetch-property-instance">
    <!-- the property for which the instance is sought; it is assumed that
    the property passed has type 'entity' -->
    <xsl:param name="property"/>
    <!-- the name of the value in the returned values from which the instance
    must be resolved -->
    <xsl:param name="valuename"/>
    <xsl:if test="not( $property/@type='entity')">
      <xsl:message terminate="yes">
        ADL: ERROR: property passed to fetch-property-instance whose type is not 'entity'
      </xsl:message>
    </xsl:if>
              hibernator.CreateCriteria(typeof(<xsl:value-of select="concat( $entityns, '.', $property/@entity)"/>))
    <xsl:for-each select="//adl:entity[@name=$property/@entity]/adl:key/adl:property">
                .Add(Expression.Eq("<xsl:value-of select="@name"/>",<xsl:choose>
        <xsl:when test="@type='entity'"><xsl:call-template name="fetch-property-instance">
            <!-- recurse -->
            <xsl:with-param name="property" select="."/>
            <xsl:with-param name="valuename" select="$valuename"/>
          </xsl:call-template></xsl:when>
        <xsl:when test="@type='integer'">Int32.Parse( Form["<xsl:value-of select="$valuename"/>"])</xsl:when>
        <xsl:otherwise>Form["<xsl:value-of select="$valuename"/>"]</xsl:otherwise>
      </xsl:choose>))
    </xsl:for-each>
                .UniqueResult&lt;<xsl:value-of select="concat( $entityns, '.', @entity)"/>&gt;()
  </xsl:template>

  <!-- this is essentially just a macro and doesn't really do anything clever. 
  It finds the current instance of the entity for which this is the controller, 
  and returns it as the value of a variable (which must have been previously 
  declared) called 'record' -->
  <xsl:template name="fetch-instance">
    <xsl:param name="entity"/>
      <xsl:value-of select="concat($entityns, '.', $entity/@name)"/> record = null;  

        /* check whether values for all key slots have been passed in; if so, we're probably dealing with an
         * existing record */
        bool allkeys = true;
    <xsl:for-each select="$entity/adl:key/adl:property">
        if ( String.IsNullOrEmpty( Form["<xsl:value-of select="concat( 'instance.', @name)"/>"])) {
          allkeys = false;
        }
        else if ( "<xsl:value-of select="concat('$instance.', @name)"/>".Equals( Form["<xsl:value-of select="concat( 'instance.', @name)"/>"])) {
          /* nasty artefact of NVelocity forms - default 'null value' is dollar followed by fieldname */
          allkeys = false;
        }
    </xsl:for-each>

        if ( allkeys){
          /* it's (probably) existing, retrieve it */

          record = hibernator.CreateCriteria(typeof(<xsl:value-of select="concat( $entityns, '.', $entity/@name)"/>))
    <xsl:for-each select="$entity/adl:key/adl:property">
      <xsl:variable name="basetype">
        <xsl:call-template name="base-type">
          <xsl:with-param name="property" select="."/>
        </xsl:call-template>
      </xsl:variable>
            .Add( Expression.Eq( "<xsl:value-of select="@name"/>", <xsl:choose>
        <xsl:when test="$basetype='integer'">Int32.Parse( Form[ "<xsl:value-of select="concat( 'instance.', @name)"/>"])</xsl:when>
        <xsl:when test="$basetype='entity'">
          <!-- Maybe TODO: this doesn't work recursively - if an entity has a key which is an entity 
                  and the key of that entity is an entity, you're on your own, mate! -->
          <xsl:variable name="keyentity" select="@entity"/>
          <xsl:variable name="keyenttype">
            <xsl:call-template name="primary-key-csharp-type">
              <xsl:with-param name="entity" select="//adl:entity[@name=$keyentity]"/>
            </xsl:call-template>
          </xsl:variable>
              hibernator.CreateCriteria( typeof( <xsl:value-of select="$keyenttype"/>))
                .Add(Expression.Eq( "<xsl:value-of select="//adl:entity[@name=$keyentity]/adl:key/adl:property[position()=1]/@name"/>",<xsl:choose>
            <xsl:when test="$keyenttype = 'int'">Int32.Parse( Form[ "<xsl:value-of select="concat( 'instance.', @name)"/>"])</xsl:when>
            <xsl:otherwise>Form[ "<xsl:value-of select="concat( 'instance.', @name)"/>"]</xsl:otherwise></xsl:choose>))
                .UniqueResult&lt;<xsl:value-of select="$keyenttype"/>&gt;()</xsl:when>
        <xsl:otherwise>Form[ "<xsl:value-of select="concat( 'instance.', @name)"/>"]</xsl:otherwise></xsl:choose>))
    </xsl:for-each>
            .UniqueResult&lt;<xsl:value-of select="concat( $entityns, '.', $entity/@name)"/>&gt;();
        }
  </xsl:template>
 </xsl:stylesheet>