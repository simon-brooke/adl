<?xml version="1.0" encoding="UTF-8" ?>  
  <!--
    C1873 SRU Hospitality
    adl2entityclass.xsl
    
    (c) 2007 Cygnet Solutions Ltd
    
    Transform ADL into entity classes
    
    $Author: af $
    $Revision: 1.1 $
    $Date: 2008-01-09 15:01:45 $
  -->

  <!-- WARNING WARNING WARNING: Do NOT reformat this file! 
     Whitespace (or lack of it) is significant! -->
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
      <xsl:output encoding="UTF-8" method="text"/>

  <!-- The locale for which these entities are generated 
      TODO: Entities should NOT be locale specific. Instead, the
      entity should generate messages based on the 
      client's locale. However, there may still need to be a concept of a
      'default locale', for when we don't have messages which suit the
      client's locale -->
  <xsl:param name="locale" select="en-UK"/>

  <!-- The C# namespace within which I shall generate controllers -->
  <xsl:param name="controllerns" select="Unset"/>
  <!-- The C# namespace within which I shall generate entities -->
  <xsl:param name="entityns" select="Unset"/>

  <xsl:template match="application">
    <xsl:apply-templates select="entity"/>
  </xsl:template>

  <xsl:template match="application">
    <xsl:apply-templates select="entity"/>
  </xsl:template>

  <xsl:template match="entity">
    <!-- what's all this about? the objective is to get the revision number of the 
    transform into the output, /without/ getting that revision number overwritten 
    with the revision number of the generated file if the generated file is 
    stored to CVS -->

    <xsl:variable name="transform-rev1"
                  select="substring( '$Revision: 1.1 $', 11)"/>
    <xsl:variable name="transform-revision"
                  select="substring( $transform-rev1, 0, string-length( $transform-rev1) - 1)"/>

    /* ---- [ cut here: next file '<xsl:value-of select="@name"/>.auto.cs'] ---------------- */

    //-------------------------------------------------------------
    //
    //  Application Description Framework
    //  <xsl:value-of select="@name"/>.auto.cs
    //
    //  (c)2007 Cygnet Solutions Ltd
    //
    //  Automatically generated from application description using
    //  adl2entityclass.xsl version <xsl:value-of select="$transform-revision"/>
    //
    //  This file is automatically generated; DO NOT EDIT IT.
    //
    //-------------------------------------------------------------
    namespace <xsl:value-of select="$entityns"/>
    {
      using System;
      using System.Configuration;
      using System.Collections;
      using System.Collections.Generic;
      using System.Text;
      using System.Text.RegularExpressions;
      using ADL.Exceptions;
      using Iesi.Collections.Generic;

      /// &lt;summary&gt;
      /// Automatically generated from description of entity <xsl:value-of select="@name"/>
      /// using adl2entityclass.xsl. Note that manually maintained parts of this
      /// class may be defined in a separate file called <xsl:value-of select="@name"/>.cs, q.v.
      ///
      /// DO NOT EDIT THIS FILE!
      /// &lt;/summary&gt;
      public partial class <xsl:value-of select="@name"/> : Entity
      {
        /// &lt;summary&gt;
        /// Auto-generated no-args constructor; does nothing (but probably should
        /// ensure ID slot is initialised correctly)
        /// &lt;/summary&gt;
        public <xsl:value-of select="@name"/>() : base(){
        <xsl:call-template name="initialise-lists"/>
        }

        /// &lt;summary&gt;
        /// Auto-generated one-arg constructor; initialises Id slot and also all 
        /// one-to-many slots
        /// &lt;/summary&gt;
        public <xsl:value-of select="@name"/>( int key)
        {
        <xsl:call-template name="initialise-lists"/>

        <xsl:choose>
          <xsl:when test="@natural-key">
          /* natural primary key exists - not initialising abstract key */
          </xsl:when>
          <xsl:otherwise>
          _<xsl:value-of select="@name"/>Id = key;
          </xsl:otherwise>
        </xsl:choose>
        }

        <xsl:choose>
          <xsl:when test="@natural-key">
        /* natural primary key exists - not generating abstract key */
          </xsl:when>
          <xsl:otherwise>
        /// &lt;summary&gt;
        /// Auto-generated iv/property for Id slot
        /// &lt;/summary&gt;
        private int _<xsl:value-of select="@name"/>Id = -1;

        public virtual int <xsl:value-of select="@name"/>Id
        {
          get { return _<xsl:value-of select="@name"/>Id; }
          set { _<xsl:value-of select="@name"/>Id = value; }
        }
        
        /// &lt;summary&gt;
        /// Auto-generated overridden property for the Key slot, maps onto
        /// _<xsl:value-of select="@name"/>Id
        /// &lt;/summary&gt;
        public override int Key
        {
          get { return _<xsl:value-of select="@name"/>Id; }
        }
          </xsl:otherwise>
        </xsl:choose>
        
        /// &lt;summary&gt;
        /// A user readable distinct identifying string
        /// &lt;/summary&gt;        
        public override string UserIdentifier
        {
          get {
            StringBuilder result = new StringBuilder();
          <xsl:choose>
            <xsl:when test="property[@distinct='user']">
              <xsl:for-each select="property[@distinct='user']">
                <xsl:choose>
                  <xsl:when test="@type='entity'">
                    <!-- TODO: this is dangerous and could potentially give rise to 
                      infinite loops; find a way of stopping it running away! -->
            result.Append( <xsl:value-of select="concat( @name, '.UserIdentifier')"/>);
                  </xsl:when>
                  <xsl:otherwise>
            result.Append(<xsl:value-of select="concat( '_', @name)"/>);
                  </xsl:otherwise>
                </xsl:choose>
                <xsl:choose>
              <xsl:when test="position() = last()"/>
              <xsl:otherwise>
            result.Append( ", ");
              </xsl:otherwise>
            </xsl:choose>
              </xsl:for-each>
            </xsl:when>
            <xsl:otherwise>
            result.AppendFormat( "<xsl:value-of select="@name"/>#{0}[", _<xsl:value-of select="@name"/>Id);
            </xsl:otherwise>
          </xsl:choose>
          
            return result.ToString();
          }
        }
    
    <xsl:apply-templates select="property"/>
      }
    }


  </xsl:template>

  <xsl:template match="property[@concrete='false']">
    <!-- generate nothing for non-concrete properties -->
  </xsl:template>
  
  <xsl:template match="property">
        // auto generating iv/property pair for slot with name <xsl:value-of select="@name"/>
    <xsl:apply-templates select="help"/>

    <xsl:variable name="defined-type">
      <xsl:choose>
        <xsl:when test="@type='defined'">
          <xsl:variable name="definition">
            <xsl:value-of select="@definition"/>
          </xsl:variable>
          <xsl:value-of select="/application/definition[@name=$definition]/@type"/>
        </xsl:when>
      </xsl:choose>
    </xsl:variable>

    <xsl:variable name="type">
      <xsl:choose>
        <xsl:when test="@type = 'link'">
          ICollection&lt;<xsl:value-of select="@entity"/>&gt;
        </xsl:when>
        <xsl:when test="@type = 'list'">
          ICollection&lt;<xsl:value-of select="@entity"/>&gt;
        </xsl:when>
        <xsl:when test="@type = 'date'">DateTime</xsl:when>
        <xsl:when test="@type = 'time'">DateTime</xsl:when>
        <xsl:when test="@type = 'string'">String</xsl:when>
        <xsl:when test="@type = 'text'">String</xsl:when>
        <xsl:when test="@type = 'boolean'">bool</xsl:when>
        <xsl:when test="@type = 'timestamp'">TimeStamp</xsl:when>
        <xsl:when test="@type = 'integer'">int</xsl:when>
        <xsl:when test="@type = 'real'">double</xsl:when>
        <xsl:when test="@type = 'money'">Decimal</xsl:when>
        <xsl:when test="@type = 'entity'">
          <xsl:value-of select="@entity"/>
        </xsl:when>
        <xsl:when test="@type='defined'">
          <!-- MUCH more complicated... find the right definition, then map its type onto a C# type -->
          <xsl:choose>
            <!-- DefinableDataTypes are string|integer|real|money|date|time|timestamp -->
            <xsl:when test="$defined-type = 'string'">String</xsl:when>
            <xsl:when test="$defined-type = 'integer'">int</xsl:when>
            <xsl:when test="$defined-type = 'real'">double</xsl:when>
            <xsl:when test="$defined-type = 'money'">Decimal</xsl:when>
            <xsl:when test="$defined-type = 'date'">DateTime</xsl:when>
            <xsl:when test="$defined-type = 'time'">DateTime</xsl:when>
            <xsl:when test="$defined-type = 'timestamp'">TimeStamp</xsl:when>
          </xsl:choose>
        </xsl:when>
        <xsl:otherwise>[unknown?]</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="nullable-decoration">
      <xsl:choose>
        <xsl:when test="@required='true'"/>
        <!-- when required is 'true' null is not permitted anyway; otherwise... -->
        <xsl:when test="$type = 'int'">?</xsl:when>
        <xsl:when test="@type = 'boolean'">?</xsl:when>
        <xsl:when test="$type = 'double'">?</xsl:when>
        <xsl:when test="$type = 'Double'">?</xsl:when>
        <xsl:when test="$type = 'DateTime'">?</xsl:when>
        <xsl:when test="$type = 'TimeStamp'">?</xsl:when>
        <xsl:otherwise/>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="initialiser">
      <xsl:choose>
        <xsl:when test="@default">
          <xsl:choose>
            <xsl:when test="$type = 'String'"> = "<xsl:value-of select="@default"/>"</xsl:when>
            <xsl:otherwise> = <xsl:value-of select="@default"/></xsl:otherwise>
          </xsl:choose>
        </xsl:when>
        <xsl:when test="$nullable-decoration = '?'"> = null</xsl:when>
        <xsl:when test="@type = 'boolean'"> = false</xsl:when>
        <xsl:when test="$type = 'int'"> = 0</xsl:when>
        <xsl:when test="$type = 'double'"> = 0.0</xsl:when>
        <xsl:when test="$type = 'Decimal'"> = 0.0M</xsl:when>
        <xsl:when test="$type='String'"> = null</xsl:when>
      </xsl:choose>
    </xsl:variable>

    <xsl:variable name="validationpattern">
      <xsl:choose>
        <xsl:when test="@type='defined'">
          <xsl:variable name="definition">
            <xsl:value-of select="@definition"/>
          </xsl:variable>
          <xsl:value-of select="/application/definition[@name=$definition]/@pattern"/>
        </xsl:when>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="string-length( $validationpattern) &gt; 0">
        private Regex <xsl:value-of select="@name"/>Validator = new Regex( "<xsl:value-of select="$validationpattern"/>");
    </xsl:if>

        private <xsl:value-of select="$type"/><xsl:value-of select="$nullable-decoration"/> _<xsl:value-of select="@name"/> <xsl:value-of select="$initialiser"/>;

        public virtual <xsl:value-of select="$type"/><xsl:value-of select="$nullable-decoration"/><xsl:text> </xsl:text> <xsl:value-of select="@name"/>
        {
          get { return _<xsl:value-of select="@name"/>; }
          set {
          <xsl:if test="@required='true'">
            if ( value == null)
            {
              throw new DataRequiredException( <xsl:choose>
                <xsl:when test="ifmissing[@locale=$locale]">
                  <xsl:apply-templates select="ifmissing"/>
                </xsl:when>
                <xsl:otherwise>
                  "The value for <xsl:value-of select="@name"/> may not be set to null"
                </xsl:otherwise>
              </xsl:choose>
                );
            }
          </xsl:if>
  <xsl:if test="@type='defined'">
    <xsl:variable name="definition">
      <xsl:value-of select="@definition"/>
    </xsl:variable>
    <xsl:variable name="maximum">
      <xsl:value-of select="/application/definition[@name=$definition]/@maximum"/>
    </xsl:variable>
    <xsl:variable name="minimum">
      <xsl:value-of select="/application/definition[@name=$definition]/@minimum"/>
    </xsl:variable>
    <xsl:if test="string-length( $maximum) &gt; 0">
            if ( value &gt; <xsl:value-of select="$maximum"/>)
            {
              throw new DataRangeException( "The maximum permitted value for <xsl:value-of select="@name"/> is <xsl:value-of select="$maximum"/>");
            }
    </xsl:if>
    <xsl:if test="string-length( $minimum) &gt; 0">
            if ( value &lt; <xsl:value-of select="$minimum"/>)
            {
              throw new DataRangeException( "The minimum permitted value for <xsl:value-of select="@name"/> is <xsl:value-of select="$minimum"/>");
            }
    </xsl:if>
    <xsl:if  test="string-length( $validationpattern) &gt; 0">
            if ( value != null &amp;&amp; ! <xsl:value-of select="@name"/>Validator.IsMatch( value))
            {
              throw new DataFormatException( string.Format( "The value supplied ({0}) does not match the format required by <xsl:value-of select="@name"/>", value));
            }
    </xsl:if>
  </xsl:if>
    <xsl:if test="@size and $type='String'">
            if ( value != null &amp;&amp; value.Length > <xsl:value-of select="@size"/>)
            {
              value = value.Substring( 0, <xsl:value-of select="@size"/>);
            }
    </xsl:if>
            _<xsl:value-of select="@name"/> = value;
          }
        }

  </xsl:template>

  <xsl:template match="help">
    <xsl:if test="@locale=$locale">
    <!-- might conceivably be more than one line -->
      <xsl:text>
        /* </xsl:text><xsl:apply-templates/> */
    </xsl:if>
  </xsl:template>
  
  <xsl:template match="ifmissing">
    <xsl:if test="@locale=$locale">
                  "<xsl:value-of select="normalize-space(.)"/>"
    </xsl:if>
  </xsl:template>

  <xsl:template name="initialise-lists">
    <!-- initialise all cocrete lists and links -->
    <xsl:for-each select="property[@type='list']">
      <xsl:choose>
        <xsl:when test="@concrete='false'"/>
        <xsl:otherwise>
      _<xsl:value-of select="@name"/> = new HashedSet&lt;<xsl:value-of select="@entity"/>&gt;();
        </xsl:otherwise>
      </xsl:choose>
    </xsl:for-each>
    <xsl:for-each select="property[@type='link']">
      <xsl:choose>
        <xsl:when test="@concrete='false'"/>
        <xsl:otherwise>
      _<xsl:value-of select="@name"/> = new HashedSet&lt;<xsl:value-of select="@entity"/>&gt;();
        </xsl:otherwise>
      </xsl:choose>
    </xsl:for-each>
  </xsl:template>
  
</xsl:stylesheet>